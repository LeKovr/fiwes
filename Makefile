# exam project makefile

SHELL          = /bin/bash

# -----------------------------------------------------------------------------
# Build config

GO            ?= go
VERSION       ?= $(shell git describe --tags)
SOURCES       ?= *.go */*.go

# -----------------------------------------------------------------------------
# Docker image config

# application name, docker-compose prefix
PROJECT_NAME  ?= $(shell basename $$PWD)

# Hardcoded in docker-compose.yml service name
DC_SERVICE    ?= app

# Generated docker image
DC_IMAGE      ?= counter

# docker/compose version
DC_VER        ?= 1.14.0

# golang image version
GO_VER        ?= latest

# docker app for change inside containers
DOCKER_BIN    ?= docker

# -----------------------------------------------------------------------------
# App config

# Docker container port
SERVER_PORT   ?= 50051

# Database file in mounted volume
DB_FILE ?= /data/counter.db

# -----------------------------------------------------------------------------

.PHONY: all gen doc build-standalone coverage cov-html build test lint fmt vet vendor up down build-docker clean-docker

##
## Available targets are:
##

# default: show target list
all: help

doc:
	@echo "Open http://localhost:6060/pkg/lekovr/exam"
	@godoc -http=:6060

# ------------------------------------------------------------------------------

## generate embedded filesystems for tests
gen:
	$(GO) generate ./...

## Build cmds for scratch docker
build-standalone: lint vet coverage
	CGO_ENABLED=0 GOOS=linux go build -a ./cmd/server
	CGO_ENABLED=0 GOOS=linux go build -a ./cmd/client

## Build cmds with checks
build-all: lint vet cov build

## Build cmds
build: 
	go build -ldflags "-X main.version=$(VERSION)" .

## Format go sources
fmt:
	$(GO) fmt ./...

## Run vet
vet:
	$(GO) vet ./...

# ------------------------------------------------------------------------------

## run linter
lint:
	golint ./...
	golangci-lint run ./...

# ------------------------------------------------------------------------------

## run tests and fill coverage.out
cov: coverage.out

# internal target
coverage.out: $(SOURCES)
	$(GO) test -race -coverprofile=$@ -covermode=atomic -v ./...

## open browser with coverage report
cov-html: cov
	$(GO) tool cover -html=coverage.out

cov-clean:
	rm -f coverage.*

# Count lines of code (including tests)
cloc: cloc.md

cloc.md: $(SOURCES)
	cloc --by-file --not-match-f='(_mock_test.go|.sql|ml|.md|Makefile|resource.go)$$' --md . > $@


# ------------------------------------------------------------------------------
# Docker part
# ------------------------------------------------------------------------------

## Start service in container
up:
up: CMD=up -d $(DC_SERVICE)
up: dc

## Stop service
down:
down: CMD=rm -f -s $(DC_SERVICE)
down: dc

## Build docker image
build-docker:
	@$(MAKE) -s dc CMD="build --no-cache --force-rm $(DC_SERVICE)"

# Remove docker image & temp files
clean-docker: clean-test-docker
	[[ "$$($(DOCKER_BIN) images -q $(DC_IMAGE) 2> /dev/null)" == "" ]] || $(DOCKER_BIN) rmi $(DC_IMAGE)

# Remove test temp files
clean-test-docker:
	[ -f test-docker.get ] && rm test-docker.get || true
	[ -f test-docker.sh ] && rm test-docker.sh || true

## Test project via docker
test-docker: clean-test-docker test-docker.get
	@diff -c t/$@.want $@.get && echo "Test completed successfully."

# Run test bash script
test-docker.get: test-docker.sh
	bash $< > $@

# Generate test bash script from scenario
test-docker.sh: t/test-docker.sc
	@echo "# This file generated by make $@" > $@; \
  cat $< | \
  while read cmd; do  \
    if [[ "$$cmd" == "restart" ]] ; then \
     echo $(MAKE) -s dc 'CMD="restart $(DC_SERVICE)"' >> $@ ; \
    elif [[ "$$cmd" == "kill" ]] ; then \
     echo $(MAKE) -s dc 'CMD="kill $(DC_SERVICE)"' >> $@ ; \
    elif [[ "$$cmd" == "start" ]] ; then \
     echo DB_FILE=/data.db $(MAKE) -s dc 'CMD="up -d $(DC_SERVICE)" 1>&2' >> $@ ; # this may out whole build process logs \
    elif [[ "$$cmd" == "stop" ]] ; then \
     echo $(MAKE) -s dc 'CMD="rm -f -s $(DC_SERVICE)" 1>&2' >> $@ ; \
    else \
     echo $(DOCKER_BIN) run --net $(PROJECT_NAME)_default --rm -i $(DC_IMAGE) \
      /client --connect $(DC_SERVICE):50051 --log_level warn --log_stdout $$cmd '2>&1' >> $@ ; \
    fi \
  done ;\

# ------------------------------------------------------------------------------

# $$PWD используется для того, чтобы текущий каталог был доступен в контейнере по тому же пути
# и относительные тома новых контейнеров могли его использовать
## run docker-compose
dc: docker-compose.yml
	@$(DOCKER_BIN) run --rm  -i \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v $$PWD:$$PWD \
  -w $$PWD \
  --env=golang_version=$(GO_VER) \
  --env=SERVER_PORT=$(SERVER_PORT) \
  --env=DB_FILE=$(DB_FILE) \
  --env=DC_IMAGE=$(DC_IMAGE) \
  docker/compose:$(DC_VER) \
  -p $(PROJECT_NAME) \
  $(CMD)

## Show available make targets
help:
	@grep -A 1 "^##" Makefile | less
